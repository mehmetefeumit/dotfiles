#!/usr/bin/env bash
#
# sync-upstream - Sync upstream changes to origin and local
#
# This script:
# 1. Fetches latest changes from upstream
# 2. Merges upstream/main into local main
# 3. Pushes to origin/main
# 4. Returns you to your original branch
#
# Usage: sync-upstream [options]
#
# Options:
#   -b, --branch NAME    Branch to sync (default: main)
#   -r, --rebase        Use rebase instead of merge
#   -n, --dry-run       Show what would be done
#   -h, --help          Show this help
#

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Configuration
BRANCH="${BRANCH:-main}"
USE_REBASE=false
DRY_RUN=false

# Print functions
error() {
  echo -e "${RED}✗${NC} $*" >&2
  exit 1
}
success() { echo -e "${GREEN}✓${NC} $*"; }
warning() { echo -e "${YELLOW}⚠${NC} $*"; }
info() { echo -e "${BLUE}ℹ${NC} $*"; }
step() { echo -e "${CYAN}→${NC} $*"; }

# Show help
show_help() {
  sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
  exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  -b | --branch)
    BRANCH="$2"
    shift 2
    ;;
  -r | --rebase)
    USE_REBASE=true
    shift
    ;;
  -n | --dry-run)
    DRY_RUN=true
    shift
    ;;
  -h | --help)
    show_help
    ;;
  *)
    error "Unknown option: $1. Use --help for usage."
    ;;
  esac
done

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  Syncing Upstream → Origin → Local"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

[ "$DRY_RUN" = true ] && warning "DRY RUN MODE - No changes will be made"

# ============================================
# PRE-FLIGHT CHECKS
# ============================================

step "Running pre-flight checks..."

# Check if in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
  error "Not in a git repository"
fi

# Check if upstream remote exists
if ! git remote get-url upstream &>/dev/null; then
  error "No 'upstream' remote found. Add it with:
  git remote add upstream <upstream-url>"
fi

# Check if origin remote exists
if ! git remote get-url origin &>/dev/null; then
  error "No 'origin' remote found"
fi

# Save current branch
CURRENT_BRANCH=$(git branch --show-current)
if [ -z "$CURRENT_BRANCH" ]; then
  error "Detached HEAD state. Please checkout a branch first."
fi

info "Current branch: $CURRENT_BRANCH"
info "Syncing branch: $BRANCH"

# Check if target branch exists locally
if ! git show-ref --verify --quiet "refs/heads/$BRANCH"; then
  error "Branch '$BRANCH' doesn't exist locally. Create it first or use --branch to specify a different branch."
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
  error "You have uncommitted changes. Commit or stash them first:
  git stash
  git commit -am 'Your message'"
fi

# Check for unpushed commits on current branch (if not on target branch)
if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
  UNPUSHED=$(git log origin/"$CURRENT_BRANCH".."$CURRENT_BRANCH" --oneline 2>/dev/null | wc -l || echo 0)
  if [ "$UNPUSHED" -gt 0 ]; then
    warning "You have $UNPUSHED unpushed commit(s) on $CURRENT_BRANCH"
    info "These will not be affected by the sync"
  fi
fi

success "All checks passed"

# Show remote info
echo ""
info "Remotes:"
git remote -v | grep -E "^(origin|upstream)" | sed 's/^/  /'
echo ""

# ============================================
# STEP 1: FETCH FROM UPSTREAM
# ============================================

step "Fetching latest changes from upstream..."

if [ "$DRY_RUN" = true ]; then
  info "[DRY RUN] Would run: git fetch upstream"
else
  if ! git fetch upstream; then
    error "Failed to fetch from upstream"
  fi
  success "Fetched from upstream"
fi

# Check if upstream branch exists
if ! git show-ref --verify --quiet "refs/remotes/upstream/$BRANCH"; then
  error "Branch '$BRANCH' doesn't exist in upstream"
fi

# Show what's new from upstream
COMMITS_BEHIND=$(git rev-list --count HEAD..upstream/"$BRANCH" 2>/dev/null || echo 0)
if [ "$COMMITS_BEHIND" -gt 0 ]; then
  info "Upstream is $COMMITS_BEHIND commit(s) ahead"
  echo ""
  echo "  New commits from upstream:"
  git log --oneline --no-merges HEAD..upstream/"$BRANCH" | head -5 | sed 's/^/    /'
  [ "$COMMITS_BEHIND" -gt 5 ] && echo "    ... and $((COMMITS_BEHIND - 5)) more"
  echo ""
else
  success "Already up to date with upstream"
  info "Nothing to sync!"
  exit 0
fi

# ============================================
# STEP 2: SWITCH TO TARGET BRANCH
# ============================================

if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
  step "Switching to $BRANCH branch..."

  if [ "$DRY_RUN" = true ]; then
    info "[DRY RUN] Would run: git checkout $BRANCH"
  else
    if ! git checkout "$BRANCH"; then
      error "Failed to checkout $BRANCH"
    fi
    success "Switched to $BRANCH"
  fi
fi

# ============================================
# STEP 3: MERGE/REBASE UPSTREAM CHANGES
# ============================================

if [ "$USE_REBASE" = true ]; then
  step "Rebasing $BRANCH onto upstream/$BRANCH..."
  MERGE_CMD="git rebase upstream/$BRANCH"
else
  step "Merging upstream/$BRANCH into $BRANCH..."
  MERGE_CMD="git merge --ff-only upstream/$BRANCH"
fi

if [ "$DRY_RUN" = true ]; then
  info "[DRY RUN] Would run: $MERGE_CMD"
else
  if ! eval "$MERGE_CMD"; then
    error "Failed to merge/rebase. Resolve conflicts manually:
  git status
  # Fix conflicts
  git add .
  $([ "$USE_REBASE" = true ] && echo "git rebase --continue" || echo "git merge --continue")"
  fi
  success "Merged upstream changes into local $BRANCH"
fi

# ============================================
# STEP 4: PUSH TO ORIGIN
# ============================================

step "Pushing $BRANCH to origin..."

if [ "$DRY_RUN" = true ]; then
  info "[DRY RUN] Would run: git push origin $BRANCH"
else
  if ! git push origin "$BRANCH"; then
    error "Failed to push to origin. Try:
  git push --force-with-lease origin $BRANCH"
  fi
  success "Pushed to origin/$BRANCH"
fi

# ============================================
# STEP 5: RETURN TO ORIGINAL BRANCH
# ============================================

if [ "$CURRENT_BRANCH" != "$BRANCH" ]; then
  step "Returning to $CURRENT_BRANCH branch..."

  if [ "$DRY_RUN" = true ]; then
    info "[DRY RUN] Would run: git checkout $CURRENT_BRANCH"
  else
    if ! git checkout "$CURRENT_BRANCH"; then
      warning "Failed to return to $CURRENT_BRANCH. You're still on $BRANCH"
    else
      success "Returned to $CURRENT_BRANCH"
    fi
  fi
fi

# ============================================
# SUMMARY
# ============================================

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
success "Sync complete!"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

if [ "$DRY_RUN" = false ]; then
  info "Summary:"
  echo "  • Synced $COMMITS_BEHIND commit(s) from upstream"
  echo "  • Local $BRANCH is now up to date"
  echo "  • Origin $BRANCH has been updated"
  [ "$CURRENT_BRANCH" != "$BRANCH" ] && echo "  • Returned to $CURRENT_BRANCH branch"
  echo ""

  info "Your branches:"
  git branch -vv | grep -E "($BRANCH|$CURRENT_BRANCH)" | sed 's/^/  /'
fi
